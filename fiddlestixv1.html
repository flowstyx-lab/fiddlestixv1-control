<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>FiddleStIX V1 Dual Control</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Chart.js for plotting IMU / mic data -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <style>
    /* Basic dark theme layout */
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #111;
      color: #eee;
      margin: 0;
      padding: 0;
    }
    header {
      padding: 1rem;
      background: #222;
      display: flex;
      justify-content: space-between;
      align-items: center;
      position: sticky;
      top: 0;
      z-index: 10;
      gap: 0.75rem;
      flex-wrap: wrap;
    }
    header h1 {
      margin: 0;
      font-size: 1.2rem;
    }
    .header-right {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    header button {
      padding: 0.5rem 1rem;
      border: none;
      border-radius: 999px;
      background: #0af;
      color: #000;
      font-weight: 600;
      cursor: pointer;
      font-size: 0.85rem;
    }
    header button.connected {
      background: #0f0;
      color: #000;
    }

    main {
      padding: 1rem;
      display: grid;
      grid-template-columns: minmax(0, 1.2fr) minmax(0, 1.1fr);
      gap: 1rem;
    }
    section {
      background: #181818;
      border-radius: 12px;
      padding: 1rem;
      box-shadow: 0 0 0 1px #222;
    }
    h2 {
      margin-top: 0;
      font-size: 1rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: #aaa;
    }

    /* Control layout */
    .controls-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
      gap: 0.5rem;
    }
    .controls-grid button {
      padding: 0.5rem;
      border-radius: 8px;
      border: none;
      background: #333;
      color: #eee;
      cursor: pointer;
      font-size: 0.85rem;
    }
    .controls-grid button:hover {
      background: #444;
    }
    .row {
      display: flex;
      align-items: center;
      margin-bottom: 0.5rem;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    label {
      font-size: 0.85rem;
      color: #bbb;
      min-width: 90px;
    }
    input[type="range"] {
      flex: 1;
    }
    .value {
      min-width: 2.5rem;
      text-align: right;
      font-size: 0.85rem;
    }

    .list-circles {
      display: flex;
      gap: 0.4rem;
      flex-wrap: wrap;
    }
    .list-circle {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      border: 2px solid transparent;
      cursor: pointer;
      box-shadow: 0 0 0 1px #333;
    }
    .list-circle.active {
      border-color: #fff;
      box-shadow: 0 0 0 2px #0af;
    }

    .bool-toggle {
      display: flex;
      align-items: center;
      gap: 0.4rem;
      margin-bottom: 0.3rem;
      font-size: 0.85rem;
    }

    .device-status-block {
      margin-top: 0.5rem;
      padding: 0.4rem 0.5rem;
      border-radius: 8px;
      background: #202020;
      border: 1px solid #333;
      font-size: 0.8rem;
    }

    .graphs-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 0.75rem;
    }
    .device-graphs {
      border-radius: 10px;
      padding: 0.5rem;
      background: #202020;
      border: 1px solid #333;
    }
    .device-graphs h3 {
      margin: 0 0 0.3rem 0;
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #ccc;
    }

    canvas {
      background: #000;
      border-radius: 8px;
    }

    .debug-box {
      margin-top: 0.5rem;
      font-size: 0.7rem;
      color: #ccc;
      background: #111;
      border-radius: 6px;
      padding: 0.5rem;
      max-height: 80px;
      overflow-y: auto;
      border: 1px solid #333;
    }

    @media (max-width: 1100px) {
      main {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
<header>
  <h1>FiddleStIX V1 Dual Control</h1>
  <div class="header-right">
    <!-- Separate connect buttons for Device #1 and Device #2 -->
    <button id="connectBtnA">Connect #1</button>
    <button id="connectBtnB">Connect #2</button>
  </div>
</header>

<main>
  <!-- LEFT: Controls + device status/debug -->
  <section id="controlSection">
    <h2>Controls (Broadcast to All Connected Devices)</h2>

    <!-- CONTROL BUTTONS (map directly to CMD:... strings the firmware understands) -->
    <div class="controls-grid">
      <button data-cmd="CMD:PREV_LIST">Previous Page</button>
      <button data-cmd="CMD:NEXT_LIST">Next Page</button>
      <button data-cmd="CMD:PREV_PATTERN">Previous Pattern</button>
      <button data-cmd="CMD:NEXT_PATTERN">Next Pattern</button>
      <button data-cmd="CMD:FAVORITE">Favorite</button>
      <button data-cmd="CMD:GO_SLEEP">Go To Sleep</button>
      <button data-cmd="CMD:RAVE">Rave O'Clock</button>
    </div>

    <hr style="border: none; border-top: 1px solid #333; margin: 1rem 0;">

    <!-- LIST SELECTOR CIRCLES (SET:LIST:n broadcast) -->
    <div class="row">
      <label>Lists</label>
      <div class="list-circles" id="listCircles"></div>
    </div>

    <!-- PATTERN SLIDER (SET:PATTERN:n broadcast) -->
    <div class="row">
      <label>Pattern #</label>
      <input type="range" id="patternSlider" min="0" max="99" value="0">
      <span class="value" id="patternSliderVal">0</span>
    </div>

    <!-- BRIGHTNESS SLIDER (SET:BRIGHT:n broadcast) -->
    <div class="row">
      <label>Brightness</label>
      <input type="range" id="brightSlider" min="0" max="7" value="7">
      <span class="value" id="brightSliderVal">7</span>
    </div>

    <!-- SHUFFLE DWELL TIME (SET:SHUFFLE_T:ms) -->
    <div class="row">
      <label>Shuffle T (ms)</label>
      <input type="range" id="shuffleSlider" min="500" max="30000" step="500" value="3000">
      <span class="value" id="shuffleSliderVal">3000</span>
    </div>

    <!-- BOOLEAN FLAGS (SET:BOOL:...:0/1) -->
    <div>
      <h2>Flags</h2>
      <div class="bool-toggle">
        <input type="checkbox" id="shuffleFlag" checked>
        <label for="shuffleFlag">Shuffle (shuffle_P)</label>
      </div>
      <div class="bool-toggle">
        <input type="checkbox" id="sleepTimerFlag" checked>
        <label for="sleepTimerFlag">Sleep Timer</label>
      </div>
      <div class="bool-toggle">
        <input type="checkbox" id="powerLockFlag">
        <label for="powerLockFlag">Power Lock</label>
      </div>
    </div>

    <!-- PER-DEVICE STATUS BLOCKS -->
    <div class="device-status-block">
      <strong>Device #1 Status</strong><br>
      State: <span id="stateLabelA">Unknown</span> ·
      List: <span id="listLabelA">-</span> ·
      Pattern: <span id="patternLabelA">-</span>
      <div class="debug-box" id="debugBoxA"></div>
    </div>

    <div class="device-status-block">
      <strong>Device #2 Status</strong><br>
      State: <span id="stateLabelB">Unknown</span> ·
      List: <span id="listLabelB">-</span> ·
      Pattern: <span id="patternLabelB">-</span>
      <div class="debug-box" id="debugBoxB"></div>
    </div>
  </section>

  <!-- RIGHT: Graphs -->
  <section id="graphsSection">
    <h2>Sensor Graphs (Last ~30s)</h2>

    <div class="graphs-grid">
      <!-- DEVICE #1 GRAPHS -->
      <div class="device-graphs">
        <h3>Device #1</h3>
        <div style="font-size:0.8rem; color:#aaa; margin-bottom:0.2rem;">Gyro (gx, gy, gz)</div>
        <canvas id="gyroCanvasA" height="100"></canvas>
        <div style="font-size:0.8rem; color:#aaa; margin:0.4rem 0 0.2rem;">Accel (ax, ay, az)</div>
        <canvas id="accelCanvasA" height="100"></canvas>
        <div style="font-size:0.8rem; color:#aaa; margin:0.4rem 0 0.2rem;">Mic RMS</div>
        <canvas id="micCanvasA" height="100"></canvas>
      </div>

      <!-- DEVICE #2 GRAPHS -->
      <div class="device-graphs">
        <h3>Device #2</h3>
        <div style="font-size:0.8rem; color:#aaa; margin-bottom:0.2rem;">Gyro (gx, gy, gz)</div>
        <canvas id="gyroCanvasB" height="100"></canvas>
        <div style="font-size:0.8rem; color:#aaa; margin:0.4rem 0 0.2rem;">Accel (ax, ay, az)</div>
        <canvas id="accelCanvasB" height="100"></canvas>
        <div style="font-size:0.8rem; color:#aaa; margin:0.4rem 0 0.2rem;">Mic RMS</div>
        <canvas id="micCanvasB" height="100"></canvas>
      </div>
    </div>
  </section>
</main>

<script>
  /********************************************************************
   * BLE UART UUIDs
   * These match Adafruit / Nordic NUS (used by Bluefruit BLEUart).
   ********************************************************************/
  const UART_SERVICE_UUID = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
  const UART_RX_CHAR_UUID = '6e400002-b5a3-f393-e0a9-e50e24dcca9e'; // Write from browser -> device
  const UART_TX_CHAR_UUID = '6e400003-b5a3-f393-e0a9-e50e24dcca9e'; // Notify from device -> browser

  // How many points to keep for ~30s history.
  // Firmware sends telemetry at 40 Hz => 30s ≈ 1200 samples.
  // We'll cap at 1200.
  const MAX_POINTS = 1200;

  function trimArray(arr) {
    while (arr.length > MAX_POINTS) arr.shift();
  }

  /********************************************************************
   * Helper: Map firmware state IDs to readable strings
   * Must match DeviceState enum in the INO.
   ********************************************************************/
  function stateNameFromId(id) {
    switch (id) {
      case 0: return 'OFF';
      case 1: return 'PLAY';
      case 2: return 'SLEEP';
      case 3: return 'SHUFFLE';
      case 4: return 'PAIRING';
      case 5: return 'L_SELECT';
      case 6: return 'B_SELECT';
      case 7: return 'T_SELECT';
      default: return '?';
    }
  }

  /********************************************************************
   * Class representing a single FiddleStIX device
   * - Manages BLE connection, notifications
   * - Parses telemetry lines
   * - Maintains data buffers + charts
   * - Updates its own status UI
   ********************************************************************/
  class FiddleDevice {
    constructor(idLetter) {
      this.id = idLetter;           // 'A' or 'B'

      // BLE objects
      this.device = null;
      this.server = null;
      this.uartService = null;
      this.rxChar = null;          // Write characteristic (browser -> device)
      this.txChar = null;          // Notify characteristic (device -> browser)

      // Incrementally build lines from BLE notifications
      this.rxBuffer = '';

      // UI elements specific to this device
      this.stateLabel   = document.getElementById('stateLabel' + idLetter);
      this.listLabel    = document.getElementById('listLabel' + idLetter);
      this.patternLabel = document.getElementById('patternLabel' + idLetter);
      this.debugBox     = document.getElementById('debugBox' + idLetter);
      this.connectBtn   = document.getElementById('connectBtn' + idLetter);

      // Data buffers for graphs (time-series)
      this.gyroData = { t: [], gx: [], gy: [], gz: [] };
      this.accelData = { t: [], ax: [], ay: [], az: [] };
      this.micData = { t: [], mic: [] };

      // Build Chart.js line charts
      this.gyroChart = new Chart(
        document.getElementById('gyroCanvas' + idLetter).getContext('2d'),
        {
          type: 'line',
          data: {
            labels: this.gyroData.t,
            datasets: [
              { label: 'gx', data: this.gyroData.gx, borderWidth: 1, pointRadius: 0 },
              { label: 'gy', data: this.gyroData.gy, borderWidth: 1, pointRadius: 0 },
              { label: 'gz', data: this.gyroData.gz, borderWidth: 1, pointRadius: 0 }
            ]
          },
          options: {
            animation: false,
            responsive: true,
            scales: {
              x: { display: false },
              y: {
                ticks: { color: '#aaa' },
                grid: { color: '#333' }
              }
            },
            plugins: {
              legend: { labels: { color: '#aaa' } }
            }
          }
        }
      );

      this.accelChart = new Chart(
        document.getElementById('accelCanvas' + idLetter).getContext('2d'),
        {
          type: 'line',
          data: {
            labels: this.accelData.t,
            datasets: [
              { label: 'ax', data: this.accelData.ax, borderWidth: 1, pointRadius: 0 },
              { label: 'ay', data: this.accelData.ay, borderWidth: 1, pointRadius: 0 },
              { label: 'az', data: this.accelData.az, borderWidth: 1, pointRadius: 0 }
            ]
          },
          options: {
            animation: false,
            responsive: true,
            scales: {
              x: { display: false },
              y: {
                ticks: { color: '#aaa' },
                grid: { color: '#333' }
              }
            },
            plugins: {
              legend: { labels: { color: '#aaa' } }
            }
          }
        }
      );

      this.micChart = new Chart(
        document.getElementById('micCanvas' + idLetter).getContext('2d'),
        {
          type: 'line',
          data: {
            labels: this.micData.t,
            datasets: [
              { label: 'mic RMS', data: this.micData.mic, borderWidth: 1, pointRadius: 0 }
            ]
          },
          options: {
            animation: false,
            responsive: true,
            scales: {
              x: { display: false },
              y: {
                ticks: { color: '#aaa' },
                grid: { color: '#333' }
              }
            },
            plugins: {
              legend: { labels: { color: '#aaa' } }
            }
          }
        }
      );
    }

    /***********************
     * Logging helper
     * - Writes to console and per-device debug box.
     ***********************/
    log(msg) {
      console.log(`[${this.id}] ${msg}`);
      if (!this.debugBox) return;
      const line = document.createElement('div');
      line.textContent = msg;
      this.debugBox.appendChild(line);
      while (this.debugBox.children.length > 50) {
        this.debugBox.removeChild(this.debugBox.firstChild);
      }
      this.debugBox.scrollTop = this.debugBox.scrollHeight;
    }

    /***********************
     * Connect / disconnect
     ***********************/
    async connect() {
      try {
        // Ask user to select a device named FiddleStIX_V1
        this.device = await navigator.bluetooth.requestDevice({
          filters: [{ namePrefix: 'FiddleStIX_V1' }],
          optionalServices: [UART_SERVICE_UUID]
        });
        this.device.addEventListener('gattserverdisconnected', () => this.onDisconnected());

        this.server = await this.device.gatt.connect();
        this.uartService = await this.server.getPrimaryService(UART_SERVICE_UUID);

        this.rxChar = await this.uartService.getCharacteristic(UART_RX_CHAR_UUID);
        this.txChar = await this.uartService.getCharacteristic(UART_TX_CHAR_UUID);

        // Enable notifications for UART TX (device -> browser)
        await this.txChar.startNotifications();
        this.txChar.addEventListener('characteristicvaluechanged',
          (evt) => this.handleNotifications(evt)
        );

        this.setConnectedUI(true);
        this.log('Connected to FiddleStIX_V1');

      } catch (err) {
        console.error(`BLE connect error (${this.id})`, err);
        alert('BLE connection failed for device ' + this.id + ': ' + err);
        this.setConnectedUI(false);
      }
    }

    async disconnect() {
      try {
        if (this.device && this.device.gatt && this.device.gatt.connected) {
          await this.device.gatt.disconnect();
        }
      } catch (err) {
        console.error(`BLE disconnect error (${this.id})`, err);
      } finally {
        this.setConnectedUI(false);
        this.log('Disconnected');
      }
    }

    onDisconnected() {
      this.setConnectedUI(false);
      this.log('Device disconnected (GATT)');
    }

    setConnectedUI(connected) {
      if (!this.connectBtn) return;
      if (connected) {
        this.connectBtn.textContent = `Disconnect #${this.id === 'A' ? '1' : '2'}`;
        this.connectBtn.classList.add('connected');
      } else {
        this.connectBtn.textContent = `Connect #${this.id === 'A' ? '1' : '2'}`;
        this.connectBtn.classList.remove('connected');
      }
    }

    get isConnected() {
      return !!(this.device && this.device.gatt && this.device.gatt.connected);
    }

    /***********************
     * Handle incoming BLE notifications
     * - Data arrives as binary.
     * - We decode to text, accumulate into rxBuffer,
     *   then split on '\n' to process complete lines.
     ***********************/
    handleNotifications(event) {
      const value = event.target.value;
      const decoder = new TextDecoder('utf-8');
      const chunk = decoder.decode(value);
      this.rxBuffer += chunk;

      let newlineIndex;
      while ((newlineIndex = this.rxBuffer.indexOf('\n')) !== -1) {
        const line = this.rxBuffer.slice(0, newlineIndex).trim();
        this.rxBuffer = this.rxBuffer.slice(newlineIndex + 1);

        if (!line) continue;

        // For debugging, log every line you receive:
        this.log('RX: ' + line);

        if (line.startsWith('TEL,')) {
          this.parseTelemetry(line);
        } else {
          // Other text types can be handled here.
        }
      }
    }

    /***********************
     * Parse telemetry line
     * Firmware format:
     *   TEL,ms,ax,ay,az,gx,gy,gz,mic,list,pattern,state
     ***********************/
    parseTelemetry(line) {
      const parts = line.split(',');
      if (parts.length < 12) {
        this.log('Telemetry parse error (too few fields)');
        return;
      }

      const ms      = parseInt(parts[1]);
      const ax      = parseFloat(parts[2]);
      const ay      = parseFloat(parts[3]);
      const az      = parseFloat(parts[4]);
      const gx      = parseFloat(parts[5]);
      const gy      = parseFloat(parts[6]);
      const gz      = parseFloat(parts[7]);
      const mic     = parseFloat(parts[8]);
      const list    = parseInt(parts[9]);
      const pattern = parseInt(parts[10]);
      const state   = parseInt(parts[11]);

      // Push new sample into local buffers
      this.pushSensorData(ms, ax, ay, az, gx, gy, gz, mic);

      // Update labels
      this.stateLabel.textContent   = stateNameFromId(state);
      this.listLabel.textContent    = list.toString();
      this.patternLabel.textContent = pattern.toString();
    }

    /***********************
     * Store sample into buffers, trim to MAX_POINTS
     ***********************/
    pushSensorData(ms, ax, ay, az, gx, gy, gz, mic) {
      this.gyroData.t.push(ms);
      this.gyroData.gx.push(gx);
      this.gyroData.gy.push(gy);
      this.gyroData.gz.push(gz);

      this.accelData.t.push(ms);
      this.accelData.ax.push(ax);
      this.accelData.ay.push(ay);
      this.accelData.az.push(az);

      this.micData.t.push(ms);
      this.micData.mic.push(mic);

      trimArray(this.gyroData.t);
      trimArray(this.gyroData.gx);
      trimArray(this.gyroData.gy);
      trimArray(this.gyroData.gz);

      trimArray(this.accelData.t);
      trimArray(this.accelData.ax);
      trimArray(this.accelData.ay);
      trimArray(this.accelData.az);

      trimArray(this.micData.t);
      trimArray(this.micData.mic);
    }

    /***********************
     * Update Chart.js objects with latest buffers
     * (called on a timer)
     ***********************/
    updateCharts() {
      // Gyro (gx,gy,gz)
      this.gyroChart.data.labels = this.gyroData.t;
      this.gyroChart.data.datasets[0].data = this.gyroData.gx;
      this.gyroChart.data.datasets[1].data = this.gyroData.gy;
      this.gyroChart.data.datasets[2].data = this.gyroData.gz;
      this.gyroChart.update('none');

      // Accel (ax,ay,az)
      this.accelChart.data.labels = this.accelData.t;
      this.accelChart.data.datasets[0].data = this.accelData.ax;
      this.accelChart.data.datasets[1].data = this.accelData.ay;
      this.accelChart.data.datasets[2].data = this.accelData.az;
      this.accelChart.update('none');

      // Mic RMS
      this.micChart.data.labels = this.micData.t;
      this.micChart.data.datasets[0].data = this.micData.mic;
      this.micChart.update('none');
    }

    /***********************
     * Send a command string to this device
     * - str is something like "CMD:NEXT_PATTERN" or "SET:BRIGHT:5"
     * - Firmware expects newline-terminated strings.
     ***********************/
    async sendCommand(str) {
      if (!this.rxChar || !this.isConnected) return;
      const data = new TextEncoder().encode(str + '\n');
      try {
        await this.rxChar.writeValue(data);
        this.log('TX: ' + str);
      } catch (err) {
        console.error(`sendCommand error (${this.id})`, err);
        this.log('sendCommand error: ' + err);
      }
    }
  }

  /********************************************************************
   * Instantiate two device controllers: A and B
   ********************************************************************/
  const deviceA = new FiddleDevice('A');
  const deviceB = new FiddleDevice('B');
  const devices = [deviceA, deviceB]; // convenience for broadcasting

  /********************************************************************
   * Build list selector circles (single set, broadcast SET:LIST:n)
   ********************************************************************/
  const listCirclesContainer = document.getElementById('listCircles');

  const listColors = [
    '#ffffff', // 0 WHITE
    '#ff0000', // 1 RED
    '#ff7f00', // 2 ORANGE
    '#ffff00', // 3 YELLOW
    '#00ff00', // 4 GREEN
    '#0000ff', // 5 BLUE
    '#4b0082', // 6 INDIGO
    '#ee82ee', // 7 VIOLET
    '#000000'  // 8 BLACK (stub)
  ];

  function buildListCircles() {
    listCirclesContainer.innerHTML = '';
    listColors.forEach((color, idx) => {
      const div = document.createElement('div');
      div.className = 'list-circle';
      div.style.background = color;
      div.title = `List ${idx}`;
      div.dataset.listIndex = idx.toString();
      div.addEventListener('click', () => {
        broadcastCommand(`SET:LIST:${idx}`);
        highlightActiveList(idx);
      });
      listCirclesContainer.appendChild(div);
    });
  }

  function highlightActiveList(idx) {
    Array.from(listCirclesContainer.children).forEach((child, i) => {
      child.classList.toggle('active', i === idx);
    });
  }

  buildListCircles();

  /********************************************************************
   * Connect button handlers
   ********************************************************************/
  document.getElementById('connectBtnA').addEventListener('click', () => {
    if (deviceA.isConnected) deviceA.disconnect();
    else deviceA.connect();
  });

  document.getElementById('connectBtnB').addEventListener('click', () => {
    if (deviceB.isConnected) deviceB.disconnect();
    else deviceB.connect();
  });

  /********************************************************************
   * Broadcast helper: send a command to all connected devices
   ********************************************************************/
  function broadcastCommand(str) {
    for (const dev of devices) {
      if (dev.isConnected) dev.sendCommand(str);
    }
  }

  /********************************************************************
   * Attach click handlers to the control buttons
   * - Each button has data-cmd="CMD:...".
   ********************************************************************/
  document.querySelectorAll('.controls-grid button').forEach(btn => {
    btn.addEventListener('click', () => {
      const cmd = btn.dataset.cmd;
      if (cmd) broadcastCommand(cmd);
    });
  });

  /********************************************************************
   * SLIDERS + FLAGS
   ********************************************************************/
  // Pattern slider -> SET:PATTERN:n
  const patternSlider = document.getElementById('patternSlider');
  const patternSliderVal = document.getElementById('patternSliderVal');
  patternSlider.addEventListener('input', () => {
    patternSliderVal.textContent = patternSlider.value;
  });
  patternSlider.addEventListener('change', () => {
    broadcastCommand(`SET:PATTERN:${patternSlider.value}`);
  });

  // Brightness slider -> SET:BRIGHT:n
  const brightSlider = document.getElementById('brightSlider');
  const brightSliderVal = document.getElementById('brightSliderVal');
  brightSlider.addEventListener('input', () => {
    brightSliderVal.textContent = brightSlider.value;
  });
  brightSlider.addEventListener('change', () => {
    broadcastCommand(`SET:BRIGHT:${brightSlider.value}`);
  });

  // Shuffle dwell time -> SET:SHUFFLE_T:ms
  const shuffleSlider = document.getElementById('shuffleSlider');
  const shuffleSliderVal = document.getElementById('shuffleSliderVal');
  shuffleSlider.addEventListener('input', () => {
    shuffleSliderVal.textContent = shuffleSlider.value;
  });
  shuffleSlider.addEventListener('change', () => {
    broadcastCommand(`SET:SHUFFLE_T:${shuffleSlider.value}`);
  });

  // Bool flags -> SET:BOOL:...:0/1
  const shuffleFlag = document.getElementById('shuffleFlag');
  const sleepTimerFlag = document.getElementById('sleepTimerFlag');
  const powerLockFlag = document.getElementById('powerLockFlag');

  shuffleFlag.addEventListener('change', () => {
    broadcastCommand(`SET:BOOL:shuffle:${shuffleFlag.checked ? 1 : 0}`);
  });
  sleepTimerFlag.addEventListener('change', () => {
    broadcastCommand(`SET:BOOL:sleepTimer:${sleepTimerFlag.checked ? 1 : 0}`);
  });
  powerLockFlag.addEventListener('change', () => {
    broadcastCommand(`SET:BOOL:powerLock:${powerLockFlag.checked ? 1 : 0}`);
  });

  /********************************************************************
   * Chart refresh loop
   * - Telemetry is ~40 Hz; we redraw charts every 200 ms to save CPU.
   ********************************************************************/
  setInterval(() => {
    deviceA.updateCharts();
    deviceB.updateCharts();
  }, 200);
</script>
</body>
</html>
