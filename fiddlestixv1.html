<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>FiddleStIX V1 Control GUI</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
                   sans-serif;
      background: #111;
      color: #eee;
      margin: 0;
      padding: 1rem;
    }
    h1, h2 {
      margin: 0.5rem 0;
    }
    button {
      padding: 0.4rem 0.8rem;
      margin: 0.2rem;
      border-radius: 4px;
      border: 1px solid #444;
      background: #222;
      color: #eee;
      cursor: pointer;
    }
    button:disabled {
      opacity: 0.4;
      cursor: default;
    }
    button.primary {
      background: #2a5;
      border-color: #3c6;
    }
    button.danger {
      background: #a22;
      border-color: #c44;
    }
    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      margin-bottom: 0.75rem;
      align-items: center;
    }
    .card {
      border: 1px solid #333;
      border-radius: 6px;
      padding: 0.75rem;
      margin-bottom: 0.75rem;
      background: #181818;
    }
    label {
      font-size: 0.9rem;
    }
    input[type="range"] {
      width: 200px;
    }
    .small {
      font-size: 0.8rem;
      color: #aaa;
    }
    .pill {
      display: inline-block;
      padding: 0.1rem 0.4rem;
      border-radius: 999px;
      background: #222;
      border: 1px solid #444;
      font-size: 0.75rem;
      margin-right: 0.25rem;
    }
    canvas {
      background: #000;
      border-radius: 4px;
      border: 1px solid #333;
    }
    .graph-container {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
    }
    .graph-card {
      flex: 1 1 250px;
    }
  </style>
</head>
<body>
  <h1>FiddleStIX V1 Control</h1>

  <!-- ==========================
       CONNECTION & STATUS
       ========================== -->
  <div class="card">
    <div class="row">
      <button id="connectBtn" class="primary">Connect</button>
      <span id="connStatus" class="pill">Disconnected</span>
    </div>
    <div class="row">
      <div>
        <strong>State:</strong> <span id="stateText">‚Äì</span>
      </div>
      <div>
        <strong>List #:</strong> <span id="listNumText">‚Äì</span>
        <span class="small">(0=WHITE, 1=RED, 2=ORANGE, 3=YELLOW, 4=GREEN, 5=BLUE, 6=INDIGO, 7=VIOLET, 8=BLACK)</span>
      </div>
      <div>
        <strong>Pattern #:</strong> <span id="patternNumText">‚Äì</span>
      </div>
      <div>
        <strong>Last telemetry:</strong> <span id="lastTelTime">‚Äì</span>
      </div>
    </div>
  </div>

  <!-- ==========================
       PATTERN & LIST CONTROLS
       ========================== -->
  <div class="card">
    <h2>Patterns & Lists</h2>

    <div class="row">
      <button id="prevListBtn">‚üµ Prev List</button>
      <button id="nextListBtn">Next List ‚ü∂</button>
      <label>
        List select:
        <select id="listSelect">
          <option value="0">0 ‚Äì WHITE</option>
          <option value="1">1 ‚Äì RED</option>
          <option value="2">2 ‚Äì ORANGE</option>
          <option value="3">3 ‚Äì YELLOW</option>
          <option value="4">4 ‚Äì GREEN</option>
          <option value="5">5 ‚Äì BLUE</option>
          <option value="6">6 ‚Äì INDIGO</option>
          <option value="7">7 ‚Äì VIOLET</option>
          <option value="8">8 ‚Äì BLACK</option>
        </select>
      </label>
    </div>

    <div class="row">
      <button id="prevPatternBtn">‚üµ Prev Pattern</button>
      <button id="nextPatternBtn">Next Pattern ‚ü∂</button>

      <!-- Pattern index slider.
           We don't *know* at GUI-side how many patterns per list exist,
           so we provide a generic 0‚Äì31 range.
           The firmware clamps the value to the actual pattern count. -->
      <label>
        Pattern #:
        <input type="range" id="patternSlider" min="0" max="31" step="1" value="0">
        <span id="patternSliderVal">0</span>
      </label>
    </div>

    <div class="row">
      <button id="favoriteBtn">‚≠ê Favorite</button>
      <span class="small">Saves current pattern index into <code>favoritePatterns[0]</code> on the device.</span>
    </div>
  </div>

  <!-- ==========================
       BRIGHTNESS & SHUFFLE
       ========================== -->
  <div class="card">
    <h2>Brightness & Shuffle</h2>

    <div class="row">
      <label>
        Global brightness (0‚Äì7):
        <input type="range" id="brightSlider" min="0" max="7" step="1" value="7">
        <span id="brightSliderVal">7</span>
      </label>
    </div>

    <div class="row">
      <!-- shuffle_P flag -->
      <label>
        <input type="checkbox" id="shuffleCheckbox">
        Shuffle enabled (<code>shuffle_P</code>)
      </label>

      <!-- sleepTimer flag -->
      <label>
        <input type="checkbox" id="sleepTimerCheckbox" checked>
        Sleep timer enabled
      </label>

      <!-- powerLock flag -->
      <label>
        <input type="checkbox" id="powerLockCheckbox">
        Power lock (prevents single-click ON from OFF)
      </label>
    </div>

    <div class="row">
      <!-- Shuffle period slider, in seconds. Converts to ms for SHUFFLE_T. -->
      <label>
        Shuffle period:
        <input type="range" id="shuffleTSlider" min="0.5" max="15" step="0.5" value="5">
        <span id="shuffleTVal">5.0</span> s
      </label>
      <span class="small">
        Sent as <code>SET:SHUFFLE_T:&lt;ms&gt;</code> (min 500 ms) to the device.
      </span>
    </div>
  </div>

  <!-- ==========================
       STATE / MODE CONTROLS
       ========================== -->
  <div class="card">
    <h2>Modes</h2>

    <div class="row">
      <button id="raveBtn" class="primary">
        üåà Rave (global shuffle)
      </button>
      <button id="sleepBtn">
        üò¥ Sleep
      </button>
    </div>

    <div class="row small">
      <div>
        <strong>Note:</strong> some state transitions are still handled entirely
        on-device by button presses:
        <ul>
          <li>5-rapid-click "bailout" ‚Üí <code>STATE_OFF</code></li>
          <li>Medium / long / very-long presses ‚Üí SHUFFLE / L_SELECT / T_SELECT</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- ==========================
       LIVE TELEMETRY GRAPHS
       ========================== -->
  <div class="card">
    <h2>Telemetry</h2>
    <div class="graph-container">
      <div class="graph-card">
        <strong>Acceleration |a| (g-ish)</strong><br>
        <canvas id="accelCanvas" width="320" height="160"></canvas>
      </div>
      <div class="graph-card">
        <strong>Gyro |œâ| (deg/s-ish)</strong><br>
        <canvas id="gyroCanvas" width="320" height="160"></canvas>
      </div>
      <div class="graph-card">
        <strong>Mic Level (RMS)</strong><br>
        <canvas id="micCanvas" width="320" height="160"></canvas>
      </div>
    </div>
  </div>

  <script>
    // ==========================
    // BLE CONSTANTS (Adafruit / Bluefruit UART)
    // ==========================
    const NUS_SERVICE_UUID       = "6e400001-b5a3-f393-e0a9-e50e24dcca9e";
    const NUS_RX_CHAR_UUID       = "6e400002-b5a3-f393-e0a9-e50e24dcca9e"; // write
    const NUS_TX_CHAR_UUID       = "6e400003-b5a3-f393-e0a9-e50e24dcca9e"; // notify

    let bleDevice = null;
    let gattServer = null;
    let nusService = null;
    let rxChar = null; // device RX == browser TX
    let txChar = null; // device TX == browser RX (notify)

    let connected = false;

    const connStatusEl    = document.getElementById("connStatus");
    const stateTextEl     = document.getElementById("stateText");
    const listNumTextEl   = document.getElementById("listNumText");
    const patternNumTextEl= document.getElementById("patternNumText");
    const lastTelTimeEl   = document.getElementById("lastTelTime");

    const listSelectEl        = document.getElementById("listSelect");
    const patternSliderEl     = document.getElementById("patternSlider");
    const patternSliderValEl  = document.getElementById("patternSliderVal");
    const brightSliderEl      = document.getElementById("brightSlider");
    const brightSliderValEl   = document.getElementById("brightSliderVal");
    const shuffleCheckboxEl   = document.getElementById("shuffleCheckbox");
    const sleepTimerCheckboxEl= document.getElementById("sleepTimerCheckbox");
    const powerLockCheckboxEl = document.getElementById("powerLockCheckbox");
    const shuffleTSliderEl    = document.getElementById("shuffleTSlider");
    const shuffleTValEl       = document.getElementById("shuffleTVal");

    const connectBtn       = document.getElementById("connectBtn");
    const prevListBtn      = document.getElementById("prevListBtn");
    const nextListBtn      = document.getElementById("nextListBtn");
    const prevPatternBtn   = document.getElementById("prevPatternBtn");
    const nextPatternBtn   = document.getElementById("nextPatternBtn");
    const favoriteBtn      = document.getElementById("favoriteBtn");
    const raveBtn          = document.getElementById("raveBtn");
    const sleepBtn         = document.getElementById("sleepBtn");

    const accelCanvas = document.getElementById("accelCanvas");
    const gyroCanvas  = document.getElementById("gyroCanvas");
    const micCanvas   = document.getElementById("micCanvas");
    const accelCtx = accelCanvas.getContext("2d");
    const gyroCtx  = gyroCanvas.getContext("2d");
    const micCtx   = micCanvas.getContext("2d");

    // ==========================
    // TELEMETRY BUFFERS
    // ==========================
    const MAX_SAMPLES = 200;
    let accelSeries = [];
    let gyroSeries  = [];
    let micSeries   = [];

    function pushSample(series, value) {
      series.push(value);
      if (series.length > MAX_SAMPLES) {
        series.shift();
      }
    }

    function drawSeries(ctx, canvas, series, color = "#0f0") {
      const w = canvas.width;
      const h = canvas.height;

      ctx.clearRect(0, 0, w, h);

      // Border
      ctx.strokeStyle = "#333";
      ctx.lineWidth = 1;
      ctx.strokeRect(0.5, 0.5, w - 1, h - 1);

      if (!series.length) return;

      let min = Math.min(...series);
      let max = Math.max(...series);
      if (min === max) {
        min -= 1;
        max += 1;
      }

      const N = series.length;
      ctx.strokeStyle = color;
      ctx.lineWidth = 1;

      ctx.beginPath();
      for (let i = 0; i < N; i++) {
        const x = (i / (N - 1)) * (w - 4) + 2;
        const normalized = (series[i] - min) / (max - min); // 0..1
        const y = h - 2 - normalized * (h - 4);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();
    }

    function redrawGraphs() {
      drawSeries(accelCtx, accelCanvas, accelSeries, "#0f8");
      drawSeries(gyroCtx,  gyroCanvas,  gyroSeries,  "#f80");
      drawSeries(micCtx,   micCanvas,   micSeries,   "#08f");
    }

    // ==========================
    // UTILS
    // ==========================
    function setConnectedUI(isConnected) {
      connected = isConnected;
      connStatusEl.textContent = isConnected ? "Connected" : "Disconnected";
      connStatusEl.style.background = isConnected ? "#264" : "#222";
      connStatusEl.style.borderColor = isConnected ? "#3a6" : "#444";

      [
        prevListBtn, nextListBtn,
        prevPatternBtn, nextPatternBtn,
        favoriteBtn, raveBtn, sleepBtn,
        listSelectEl, patternSliderEl,
        brightSliderEl, shuffleCheckboxEl,
        sleepTimerCheckboxEl, powerLockCheckboxEl,
        shuffleTSliderEl
      ].forEach(el => {
        el.disabled = !isConnected;
      });

      connectBtn.textContent = isConnected ? "Disconnect" : "Connect";
    }

    function stateNameFromId(id) {
      switch (id) {
        case 0: return "OFF";
        case 1: return "PLAY";
        case 2: return "SLEEP";
        case 3: return "SHUFFLE";
        case 4: return "PAIRING";
        case 5: return "L_SELECT";
        case 6: return "B_SELECT";
        case 7: return "T_SELECT";
        default: return "UNKNOWN(" + id + ")";
      }
    }

    async function sendText(text) {
      if (!rxChar || !connected) return;
      const encoder = new TextEncoder();
      const data = encoder.encode(text);
      try {
        // Bluefruit UART accepts writes up to 20 bytes; chunk just in case.
        const CHUNK = 20;
        for (let i = 0; i < data.length; i += CHUNK) {
          const slice = data.slice(i, i + CHUNK);
          await rxChar.writeValueWithoutResponse(slice);
        }
      } catch (err) {
        console.error("Write failed:", err);
      }
    }

    function sendCmd(cmdStr) {
      // e.g. CMD:NEXT_LIST\n
      sendText("CMD:" + cmdStr + "\n");
    }

    function sendSet(key, value) {
      // e.g. SET:BRIGHT:5\n
      sendText("SET:" + key + ":" + value + "\n");
    }

    function sendBool(name, flag) {
      // e.g. SET:BOOL:shuffle:1\n
      const v = flag ? 1 : 0;
      sendText("SET:BOOL:" + name + ":" + v + "\n");
    }

    // ==========================
    // TELEMETRY PARSING
    // ==========================
    let rxBuffer = "";

    function handleIncomingLine(line) {
      const trimmed = line.trim();
      if (!trimmed) return;

      if (trimmed.startsWith("TEL,")) {
        // TEL,timestamp,ax,ay,az,gx,gy,gz,micLevel,listNum,patternNum,currentState
        const parts = trimmed.split(",");
        if (parts.length < 12) return;

        const timestamp   = Number(parts[1]);
        const ax          = Number(parts[2]);
        const ay          = Number(parts[3]);
        const az          = Number(parts[4]);
        const gx          = Number(parts[5]);
        const gy          = Number(parts[6]);
        const gz          = Number(parts[7]);
        const micLevel    = Number(parts[8]);
        const listNum     = Number(parts[9]);
        const patternNum  = Number(parts[10]);
        const stateId     = Number(parts[11]);

        // Update status text
        stateTextEl.textContent    = stateNameFromId(stateId);
        listNumTextEl.textContent  = listNum;
        patternNumTextEl.textContent = patternNum;
        lastTelTimeEl.textContent  =
          (new Date()).toLocaleTimeString();

        // Keep GUI controls in sync with device state (where possible)
        if (listNum >= 0 && listNum <= 8) {
          listSelectEl.value = String(listNum);
        }
        if (patternNum >= Number(patternSliderEl.min) &&
            patternNum <= Number(patternSliderEl.max)) {
          patternSliderEl.value = String(patternNum);
          patternSliderValEl.textContent = String(patternNum);
        }

        // Compute magnitude values for graphs
        const aMag = Math.sqrt(ax * ax + ay * ay + az * az);
        const gMag = Math.sqrt(gx * gx + gy * gy + gz * gz);

        pushSample(accelSeries, aMag);
        pushSample(gyroSeries,  gMag);
        pushSample(micSeries,   micLevel);

        redrawGraphs();
      }
    }

    function handleNotify(event) {
      const value = event.target.value;
      const decoder = new TextDecoder();
      const text = decoder.decode(value);

      rxBuffer += text;

      let newlineIndex;
      while ((newlineIndex = rxBuffer.indexOf("\n")) >= 0) {
        const line = rxBuffer.slice(0, newlineIndex);
        rxBuffer = rxBuffer.slice(newlineIndex + 1);
        handleIncomingLine(line);
      }
    }

    // ==========================
    // CONNECTION LOGIC
    // ==========================
    async function connect() {
      try {
        bleDevice = await navigator.bluetooth.requestDevice({
          filters: [{ namePrefix: "FiddleStIX" }], // matches "FiddleStIX_V1"
          optionalServices: [NUS_SERVICE_UUID]
        });

        bleDevice.addEventListener("gattserverdisconnected", onDisconnected);

        gattServer = await bleDevice.gatt.connect();
        nusService = await gattServer.getPrimaryService(NUS_SERVICE_UUID);
        rxChar = await nusService.getCharacteristic(NUS_RX_CHAR_UUID);
        txChar = await nusService.getCharacteristic(NUS_TX_CHAR_UUID);

        await txChar.startNotifications();
        txChar.addEventListener("characteristicvaluechanged", handleNotify);

        setConnectedUI(true);
      } catch (err) {
        console.error("BLE connect failed:", err);
        setConnectedUI(false);
      }
    }

    async function disconnect() {
      try {
        if (bleDevice && bleDevice.gatt.connected) {
          await bleDevice.gatt.disconnect();
        }
      } catch (err) {
        console.error("Disconnect error:", err);
      }
      setConnectedUI(false);
    }

    function onDisconnected() {
      setConnectedUI(false);
    }

    // ==========================
    // UI EVENT BINDINGS
    // ==========================
    connectBtn.addEventListener("click", () => {
      if (!connected) {
        connect();
      } else {
        disconnect();
      }
    });

    prevListBtn.addEventListener("click", () => {
      sendCmd("PREV_LIST");
    });

    nextListBtn.addEventListener("click", () => {
      sendCmd("NEXT_LIST");
    });

    listSelectEl.addEventListener("change", () => {
      // SET:LIST:<n>
      const ln = Number(listSelectEl.value);
      sendSet("LIST", ln);
    });

    prevPatternBtn.addEventListener("click", () => {
      sendCmd("PREV_PATTERN");
    });

    nextPatternBtn.addEventListener("click", () => {
      sendCmd("NEXT_PATTERN");
    });

    patternSliderEl.addEventListener("input", () => {
      patternSliderValEl.textContent = patternSliderEl.value;
    });

    patternSliderEl.addEventListener("change", () => {
      const pn = Number(patternSliderEl.value);
      // SET:PATTERN:<n>
      sendSet("PATTERN", pn);
    });

    favoriteBtn.addEventListener("click", () => {
      sendCmd("FAVORITE");
    });

    brightSliderEl.addEventListener("input", () => {
      brightSliderValEl.textContent = brightSliderEl.value;
    });

    brightSliderEl.addEventListener("change", () => {
      const gb = Number(brightSliderEl.value);
      sendSet("BRIGHT", gb);
    });

    shuffleCheckboxEl.addEventListener("change", () => {
      sendBool("shuffle", shuffleCheckboxEl.checked);
    });

    sleepTimerCheckboxEl.addEventListener("change", () => {
      sendBool("sleepTimer", sleepTimerCheckboxEl.checked);
    });

    powerLockCheckboxEl.addEventListener("change", () => {
      sendBool("powerLock", powerLockCheckboxEl.checked);
    });

    shuffleTSliderEl.addEventListener("input", () => {
      const seconds = Number(shuffleTSliderEl.value);
      shuffleTValEl.textContent = seconds.toFixed(1);
    });

    shuffleTSliderEl.addEventListener("change", () => {
      // Convert seconds into milliseconds; enforce >= 500 ms
      let seconds = Number(shuffleTSliderEl.value);
      let ms = Math.round(seconds * 1000);
      if (ms < 500) ms = 500;
      sendSet("SHUFFLE_T", ms);
    });

    raveBtn.addEventListener("click", () => {
      // CMD:RAVE ‚Üí changeState(STATE_SHUFFLE) + shuffle_P=true
      sendCmd("RAVE");
    });

    sleepBtn.addEventListener("click", () => {
      // CMD:GO_SLEEP ‚Üí gotoSleep()
      sendCmd("GO_SLEEP");
    });

    // Initial UI state
    setConnectedUI(false);
    patternSliderValEl.textContent = patternSliderEl.value;
    brightSliderValEl.textContent  = brightSliderEl.value;
    shuffleTValEl.textContent      = shuffleTSliderEl.value;
  </script>
</body>
</html>
