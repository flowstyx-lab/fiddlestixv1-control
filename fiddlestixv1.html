<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>FiddleStIX V1 Control</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Chart.js for graphs -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #111;
      color: #eee;
      margin: 0;
      padding: 0;
    }
    header {
      padding: 1rem;
      background: #222;
      display: flex;
      justify-content: space-between;
      align-items: center;
      position: sticky;
      top: 0;
      z-index: 10;
    }
    header h1 {
      margin: 0;
      font-size: 1.2rem;
    }
    header button {
      padding: 0.5rem 1rem;
      border: none;
      border-radius: 999px;
      background: #0af;
      color: #000;
      font-weight: 600;
      cursor: pointer;
    }
    header button.connected {
      background: #0f0;
      color: #000;
    }
    main {
      padding: 1rem;
      display: grid;
      grid-template-columns: minmax(0, 1.1fr) minmax(0, 1fr);
      gap: 1rem;
    }
    section {
      background: #181818;
      border-radius: 12px;
      padding: 1rem;
      box-shadow: 0 0 0 1px #222;
    }
    h2 {
      margin-top: 0;
      font-size: 1rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: #aaa;
    }
    .controls-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
      gap: 0.5rem;
    }
    .controls-grid button {
      padding: 0.5rem;
      border-radius: 8px;
      border: none;
      background: #333;
      color: #eee;
      cursor: pointer;
      font-size: 0.85rem;
    }
    .controls-grid button:hover {
      background: #444;
    }
    .row {
      display: flex;
      align-items: center;
      margin-bottom: 0.5rem;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    label {
      font-size: 0.85rem;
      color: #bbb;
      min-width: 90px;
    }
    input[type="range"] {
      flex: 1;
    }
    .value {
      min-width: 2.5rem;
      text-align: right;
      font-size: 0.85rem;
    }
    .list-circles {
      display: flex;
      gap: 0.4rem;
      flex-wrap: wrap;
    }
    .list-circle {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      border: 2px solid transparent;
      cursor: pointer;
      box-shadow: 0 0 0 1px #333;
    }
    .list-circle.active {
      border-color: #fff;
      box-shadow: 0 0 0 2px #0af;
    }
    .bool-toggle {
      display: flex;
      align-items: center;
      gap: 0.4rem;
      margin-bottom: 0.3rem;
      font-size: 0.85rem;
    }
    .graphs {
      display: grid;
      grid-template-columns: 1fr;
      gap: 0.5rem;
    }
    canvas {
      background: #000;
      border-radius: 8px;
    }
    .status-line {
      font-size: 0.85rem;
      color: #aaa;
      margin-bottom: 0.5rem;
      display: flex;
      align-items: center;
      gap: 0.75rem;
      flex-wrap: wrap;
    }
    .status-pill {
      padding: 0.2rem 0.6rem;
      border-radius: 999px;
      background: #333;
      font-size: 0.8rem;
    }
    .status-circle {
      width: 26px;
      height: 26px;
      border-radius: 50%;
      display: inline-flex;
      justify-content: center;
      align-items: center;
      font-size: 0.8rem;
      font-weight: 600;
      border: 2px solid #444;
    }
    .status-label-text {
      font-size: 0.8rem;
      color: #aaa;
    }
    @media (max-width: 900px) {
      main {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
<header>
  <h1>FiddleStIX V1 Control</h1>
  <button id="connectBtn">Connect</button>
</header>

<main>
  <section id="controlSection">
    <h2>Controls</h2>

    <div class="status-line">
      <span class="status-pill">
        State: <span id="stateLabel">Unknown</span>
      </span>
      <span class="status-label-text">List:</span>
      <span id="currentListCircle" class="status-circle">-</span>
      <span class="status-label-text">Pattern:</span>
      <span id="currentPatternCircle" class="status-circle">-</span>
    </div>

    <div class="controls-grid">
      <button data-cmd="CMD:PREV_LIST">Previous Page</button>
      <button data-cmd="CMD:NEXT_LIST">Next Page</button>
      <button data-cmd="CMD:PREV_PATTERN">Previous Pattern</button>
      <button data-cmd="CMD:NEXT_PATTERN">Next Pattern</button>
      <button data-cmd="CMD:FAVORITE">Favorite</button>
      <button data-cmd="CMD:GO_SLEEP">Go To Sleep</button>
      <button data-cmd="CMD:RAVE">Rave O'Clock</button>
    </div>

    <hr style="border: none; border-top: 1px solid #333; margin: 1rem 0;">

    <div class="row">
      <label>Lists</label>
      <div class="list-circles" id="listCircles">
        <!-- Circles created via JS -->
      </div>
    </div>

    <div class="row">
      <label>Pattern #</label>
      <input type="range" id="patternSlider" min="0" max="99" value="0">
      <span class="value" id="patternSliderVal">0</span>
    </div>

    <div class="row">
      <label>Brightness</label>
      <input type="range" id="brightSlider" min="0" max="7" value="7">
      <span class="value" id="brightSliderVal">7</span>
    </div>

    <div class="row">
      <label>Shuffle T (ms)</label>
      <input type="range" id="shuffleSlider" min="500" max="30000" step="500" value="5000">
      <span class="value" id="shuffleSliderVal">5000</span>
    </div>

    <div>
      <h2>Flags</h2>
      <div class="bool-toggle">
        <input type="checkbox" id="shuffleFlag">
        <label for="shuffleFlag">Shuffle (shuffle_P)</label>
      </div>
      <div class="bool-toggle">
        <input type="checkbox" id="sleepTimerFlag" checked>
        <label for="sleepTimerFlag">Sleep Timer</label>
      </div>
      <div class="bool-toggle">
        <input type="checkbox" id="powerLockFlag">
        <label for="powerLockFlag">Power Lock</label>
      </div>
    </div>
  </section>

  <section id="graphsSection">
    <h2>Sensor Graphs (last ~30s)</h2>
    <div class="graphs">
      <div>
        <div style="font-size:0.8rem; color:#aaa; margin-bottom:0.2rem;">Gyro (gx, gy, gz)</div>
        <canvas id="gyroCanvas" height="120"></canvas>
      </div>
      <div>
        <div style="font-size:0.8rem; color:#aaa; margin-bottom:0.2rem;">Accel (ax, ay, az)</div>
        <canvas id="accelCanvas" height="120"></canvas>
      </div>
      <div>
        <div style="font-size:0.8rem; color:#aaa; margin-bottom:0.2rem;">Mic Level</div>
        <canvas id="micCanvas" height="120"></canvas>
      </div>
    </div>
  </section>
</main>

<script>
  // UART UUIDs (Nordic / Adafruit BLE UART)
  const UART_SERVICE_UUID       = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
  const UART_RX_CHAR_UUID       = '6e400002-b5a3-f393-e0a9-e50e24dcca9e'; // write
  const UART_TX_CHAR_UUID       = '6e400003-b5a3-f393-e0a9-e50e24dcca9e'; // notify

  let device = null;
  let server = null;
  let uartService = null;
  let rxChar = null; // write
  let txChar = null; // notify

  const connectBtn = document.getElementById('connectBtn');
  const stateLabel = document.getElementById('stateLabel');
  const patternSlider = document.getElementById('patternSlider');
  const patternSliderVal = document.getElementById('patternSliderVal');
  const brightSlider = document.getElementById('brightSlider');
  const brightSliderVal = document.getElementById('brightSliderVal');
  const shuffleSlider = document.getElementById('shuffleSlider');
  const shuffleSliderVal = document.getElementById('shuffleSliderVal');
  const shuffleFlag = document.getElementById('shuffleFlag');
  const sleepTimerFlag = document.getElementById('sleepTimerFlag');
  const powerLockFlag = document.getElementById('powerLockFlag');
  const listCircles = document.getElementById('listCircles');
  const currentListCircle = document.getElementById('currentListCircle');
  const currentPatternCircle = document.getElementById('currentPatternCircle');

  // Graph data (approx 600 points ~30s at 20Hz)
  const MAX_POINTS = 600;
  let gyroData = { t: [], gx: [], gy: [], gz: [] };
  let accelData = { t: [], ax: [], ay: [], az: [] };
  let micData = { t: [], mic: [] };

  function trimSeries(arr) {
    while (arr.length > MAX_POINTS) arr.shift();
  }

  function pushSensorData(ms, ax, ay, az, gx, gy, gz, mic) {
    gyroData.t.push(ms);
    gyroData.gx.push(gx);
    gyroData.gy.push(gy);
    gyroData.gz.push(gz);
    accelData.t.push(ms);
    accelData.ax.push(ax);
    accelData.ay.push(ay);
    accelData.az.push(az);
    micData.t.push(ms);
    micData.mic.push(mic);

    trimSeries(gyroData.t);
    trimSeries(gyroData.gx);
    trimSeries(gyroData.gy);
    trimSeries(gyroData.gz);
    trimSeries(accelData.t);
    trimSeries(accelData.ax);
    trimSeries(accelData.ay);
    trimSeries(accelData.az);
    trimSeries(micData.t);
    trimSeries(micData.mic);
  }

  // Chart.js setup
  const gyroCtx = document.getElementById('gyroCanvas').getContext('2d');
  const accelCtx = document.getElementById('accelCanvas').getContext('2d');
  const micCtx = document.getElementById('micCanvas').getContext('2d');

  const gyroChart = new Chart(gyroCtx, {
    type: 'line',
    data: {
      labels: gyroData.t,
      datasets: [
        { label: 'gx', data: gyroData.gx, borderWidth: 1, pointRadius: 0 },
        { label: 'gy', data: gyroData.gy, borderWidth: 1, pointRadius: 0 },
        { label: 'gz', data: gyroData.gz, borderWidth: 1, pointRadius: 0 }
      ]
    },
    options: {
      animation: false,
      responsive: true,
      scales: {
        x: { display: false },
        y: {
          ticks: { color: '#aaa' },
          grid: { color: '#333' }
        }
      },
      plugins: {
        legend: { labels: { color: '#aaa' } }
      }
    }
  });

  const accelChart = new Chart(accelCtx, {
    type: 'line',
    data: {
      labels: accelData.t,
      datasets: [
        { label: 'ax', data: accelData.ax, borderWidth: 1, pointRadius: 0 },
        { label: 'ay', data: accelData.ay, borderWidth: 1, pointRadius: 0 },
        { label: 'az', data: accelData.az, borderWidth: 1, pointRadius: 0 }
      ]
    },
    options: {
      animation: false,
      responsive: true,
      scales: {
        x: { display: false },
        y: {
          ticks: { color: '#aaa' },
          grid: { color: '#333' }
        }
      },
      plugins: {
        legend: { labels: { color: '#aaa' } }
      }
    }
  });

  const micChart = new Chart(micCtx, {
    type: 'line',
    data: {
      labels: micData.t,
      datasets: [
        { label: 'mic', data: micData.mic, borderWidth: 1, pointRadius: 0 }
      ]
    },
    options: {
      animation: false,
      responsive: true,
      scales: {
        x: { display: false },
        y: {
          ticks: { color: '#aaa' },
          grid: { color: '#333' }
        }
      },
      plugins: {
        legend: { labels: { color: '#aaa' } }
      }
    }
  });

  function updateCharts() {
    gyroChart.data.labels = gyroData.t;
    gyroChart.data.datasets[0].data = gyroData.gx;
    gyroChart.data.datasets[1].data = gyroData.gy;
    gyroChart.data.datasets[2].data = gyroData.gz;
    gyroChart.update('none');

    accelChart.data.labels = accelData.t;
    accelChart.data.datasets[0].data = accelData.ax;
    accelChart.data.datasets[1].data = accelData.ay;
    accelChart.data.datasets[2].data = accelData.az;
    accelChart.update('none');

    micChart.data.labels = micData.t;
    micChart.data.datasets[0].data = micData.mic;
    micChart.update('none');
  }

  setInterval(updateCharts, 200);

  // State label helper
  function stateNameFromId(id) {
    switch (id) {
      case 0: return 'OFF';
      case 1: return 'PLAY';
      case 2: return 'SLEEP';
      case 3: return 'SHUFFLE';
      case 4: return 'PAIRING';
      case 5: return 'L_SELECT';
      case 6: return 'B_SELECT';
      case 7: return 'T_SELECT';
      default: return '?';
    }
  }

  // list colors for UI (must match C++ order)
  const listColors = [
    '#ffffff', // WHITE
    '#ff0000', // RED
    '#ff7f00', // ORANGE
    '#ffff00', // YELLOW
    '#00ff00', // GREEN
    '#0000ff', // BLUE
    '#4b0082', // INDIGO
    '#ee82ee', // VIOLET
    '#000000'  // BLACK (reserved)
  ];

  function buildListCircles() {
    listCircles.innerHTML = '';
    listColors.forEach((color, idx) => {
      const div = document.createElement('div');
      div.className = 'list-circle';
      div.style.background = color;
      div.title = `List ${idx}`;
      div.dataset.listIndex = idx.toString();
      div.addEventListener('click', () => {
        sendCommand(`SET:LIST:${idx}`);
        highlightActiveList(idx);
      });
      listCircles.appendChild(div);
    });
  }

  function highlightActiveList(idx) {
    Array.from(listCircles.children).forEach((child, i) => {
      child.classList.toggle('active', i === idx);
    });
  }

  function updateStatusCircles(listIndex, patternIndex) {
    const color = listColors[listIndex] || '#000000';

    currentListCircle.style.background = color;
    currentListCircle.textContent = listIndex.toString();
    currentListCircle.style.color = (color.toLowerCase() === '#000000') ? '#ffffff' : '#000000';

    currentPatternCircle.style.background = color;
    currentPatternCircle.textContent = patternIndex.toString();
    currentPatternCircle.style.color = (color.toLowerCase() === '#000000') ? '#ffffff' : '#000000';
  }

  buildListCircles();

  function setConnectedUI(connected) {
    if (connected) {
      connectBtn.textContent = 'Disconnect';
      connectBtn.classList.add('connected');
    } else {
      connectBtn.textContent = 'Connect';
      connectBtn.classList.remove('connected');
    }
  }

  async function connect() {
    try {
      device = await navigator.bluetooth.requestDevice({
        filters: [{ namePrefix: 'FiddleStIX_V1' }],
        optionalServices: [UART_SERVICE_UUID]
      });

      device.addEventListener('gattserverdisconnected', onDisconnected);

      server = await device.gatt.connect();
      uartService = await server.getPrimaryService(UART_SERVICE_UUID);
      rxChar = await uartService.getCharacteristic(UART_RX_CHAR_UUID);
      txChar = await uartService.getCharacteristic(UART_TX_CHAR_UUID);

      await txChar.startNotifications();
      txChar.addEventListener('characteristicvaluechanged', handleNotifications);

      setConnectedUI(true);
    } catch (err) {
      console.error('BLE connect error', err);
      alert('BLE connection failed: ' + err);
      setConnectedUI(false);
    }
  }

  async function disconnect() {
    try {
      if (device && device.gatt.connected) {
        await device.gatt.disconnect();
      }
    } catch (err) {
      console.error('BLE disconnect error', err);
    } finally {
      setConnectedUI(false);
    }
  }

  function onDisconnected() {
    console.log('Device disconnected');
    setConnectedUI(false);
  }

  function handleNotifications(event) {
    const value = event.target.value;
    const decoder = new TextDecoder('utf-8');
    const text = decoder.decode(value);

    // Could be multiple lines in one notification:
    text.split('\n').forEach(line => {
      line = line.trim();
      if (!line) return;
      if (line.startsWith('T,')) {
        parseTelemetryLine(line);
      } else {
        console.log('RX:', line);
      }
    });
  }

  function parseTelemetryLine(line) {
    // T,ms,ax,ay,az,gx,gy,gz,mic,list,pattern,state
    const parts = line.split(',');
    if (parts.length < 12) return;

    const ms = parseInt(parts[1]);
    const ax = parseFloat(parts[2]);
    const ay = parseFloat(parts[3]);
    const az = parseFloat(parts[4]);
    const gx = parseFloat(parts[5]);
    const gy = parseFloat(parts[6]);
    const gz = parseFloat(parts[7]);
    const mic = parseFloat(parts[8]);
    const list = parseInt(parts[9]);
    const pattern = parseInt(parts[10]);
    const state = parseInt(parts[11]);

    pushSensorData(ms, ax, ay, az, gx, gy, gz, mic);

    stateLabel.textContent = stateNameFromId(state);
    patternSlider.value = pattern;
    patternSliderVal.textContent = pattern.toString();
    highlightActiveList(list);
    updateStatusCircles(list, pattern);
  }

  async function sendCommand(str) {
    if (!rxChar) {
      alert('Not connected to device');
      return;
    }
    const data = new TextEncoder().encode(str + '\n');
    try {
      await rxChar.writeValue(data);
    } catch (err) {
      console.error('sendCommand error', err);
    }
  }

  // UI events
  connectBtn.addEventListener('click', () => {
    if (device && device.gatt && device.gatt.connected) {
      disconnect();
    } else {
      connect();
    }
  });

  document.querySelectorAll('.controls-grid button').forEach(btn => {
    btn.addEventListener('click', () => {
      const cmd = btn.dataset.cmd;
      if (cmd) sendCommand(cmd);
    });
  });

  patternSlider.addEventListener('input', () => {
    patternSliderVal.textContent = patternSlider.value;
  });
  patternSlider.addEventListener('change', () => {
    sendCommand(`SET:PATTERN:${patternSlider.value}`);
  });

  brightSlider.addEventListener('input', () => {
    brightSliderVal.textContent = brightSlider.value;
  });
  brightSlider.addEventListener('change', () => {
    sendCommand(`SET:BRIGHT:${brightSlider.value}`);
  });

  shuffleSlider.addEventListener('input', () => {
    shuffleSliderVal.textContent = shuffleSlider.value;
  });
  shuffleSlider.addEventListener('change', () => {
    sendCommand(`SET:SHUFFLE_T:${shuffleSlider.value}`);
  });

  shuffleFlag.addEventListener('change', () => {
    sendCommand(`SET:BOOL:shuffle:${shuffleFlag.checked ? 1 : 0}`);
  });
  sleepTimerFlag.addEventListener('change', () => {
    sendCommand(`SET:BOOL:sleepTimer:${sleepTimerFlag.checked ? 1 : 0}`);
  });
  powerLockFlag.addEventListener('change', () => {
    sendCommand(`SET:BOOL:powerLock:${powerLockFlag.checked ? 1 : 0}`);
  });
</script>
</body>
</html>
