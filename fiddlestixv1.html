<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>FiddleStIX V1 Control</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Chart.js for plotting IMU/mic data -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <style>
    /* Basic dark UI layout */
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #111;
      color: #eee;
      margin: 0;
      padding: 0;
    }
    header {
      padding: 1rem;
      background: #222;
      display: flex;
      justify-content: space-between;
      align-items: center;
      position: sticky;
      top: 0;
      z-index: 10;
    }
    header h1 {
      margin: 0;
      font-size: 1.2rem;
    }
    header button {
      padding: 0.5rem 1rem;
      border: none;
      border-radius: 999px;
      background: #0af;
      color: #000;
      font-weight: 600;
      cursor: pointer;
    }
    header button.connected {
      background: #0f0;
      color: #000;
    }
    main {
      padding: 1rem;
      display: grid;
      grid-template-columns: minmax(0, 1.1fr) minmax(0, 1fr);
      gap: 1rem;
    }
    section {
      background: #181818;
      border-radius: 12px;
      padding: 1rem;
      box-shadow: 0 0 0 1px #222;
    }
    h2 {
      margin-top: 0;
      font-size: 1rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: #aaa;
    }
    .controls-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
      gap: 0.5rem;
    }
    .controls-grid button {
      padding: 0.5rem;
      border-radius: 8px;
      border: none;
      background: #333;
      color: #eee;
      cursor: pointer;
      font-size: 0.85rem;
    }
    .controls-grid button:hover {
      background: #444;
    }
    .row {
      display: flex;
      align-items: center;
      margin-bottom: 0.5rem;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    label {
      font-size: 0.85rem;
      color: #bbb;
      min-width: 90px;
    }
    input[type="range"] {
      flex: 1;
    }
    .value {
      min-width: 2.5rem;
      text-align: right;
      font-size: 0.85rem;
    }
    .list-circles {
      display: flex;
      gap: 0.4rem;
      flex-wrap: wrap;
    }
    .list-circle {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      border: 2px solid transparent;
      cursor: pointer;
      box-shadow: 0 0 0 1px #333;
    }
    .list-circle.active {
      border-color: #fff;
      box-shadow: 0 0 0 2px #0af;
    }
    .bool-toggle {
      display: flex;
      align-items: center;
      gap: 0.4rem;
      margin-bottom: 0.3rem;
      font-size: 0.85rem;
    }
    .graphs {
      display: grid;
      grid-template-columns: 1fr;
      gap: 0.5rem;
    }
    canvas {
      background: #000;
      border-radius: 8px;
    }
    .status-line {
      font-size: 0.85rem;
      color: #aaa;
      margin-bottom: 0.5rem;
    }
    .debug-box {
      margin-top: 0.5rem;
      font-size: 0.7rem;
      color: #ccc;
      background: #111;
      border-radius: 6px;
      padding: 0.5rem;
      max-height: 120px;
      overflow-y: auto;
      border: 1px solid #333;
    }
    @media (max-width: 900px) {
      main {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
<header>
  <h1>FiddleStIX V1 Control</h1>
  <!-- Connect/disconnect button -->
  <button id="connectBtn">Connect</button>
</header>

<main>
  <!-- LEFT SIDE: Controls + status -->
  <section id="controlSection">
    <h2>Controls</h2>

    <!-- Current state info from telemetry -->
    <div class="status-line">
      Device state:
      <span id="stateLabel">Unknown</span> ·
      List: <span id="listLabel">-</span> ·
      Pattern: <span id="patternLabel">-</span>
    </div>

    <!-- Buttons that send CMD:... lines to firmware -->
    <div class="controls-grid">
      <button data-cmd="CMD:PREV_LIST">Previous Page</button>
      <button data-cmd="CMD:NEXT_LIST">Next Page</button>
      <button data-cmd="CMD:PREV_PATTERN">Previous Pattern</button>
      <button data-cmd="CMD:NEXT_PATTERN">Next Pattern</button>
      <button data-cmd="CMD:FAVORITE">Favorite</button>
      <button data-cmd="CMD:GO_SLEEP">Go To Sleep</button>
      <button data-cmd="CMD:RAVE">Rave O'Clock</button>
    </div>

    <hr style="border: none; border-top: 1px solid #333; margin: 1rem 0;">

    <!-- List selector: clickable colored circles for each list index -->
    <div class="row">
      <label>Lists</label>
      <div class="list-circles" id="listCircles"></div>
    </div>

    <!-- Pattern index slider (0–99) -->
    <div class="row">
      <label>Pattern #</label>
      <input type="range" id="patternSlider" min="0" max="99" value="0">
      <span class="value" id="patternSliderVal">0</span>
    </div>

    <!-- Global brightness slider (0–7) -->
    <div class="row">
      <label>Brightness</label>
      <input type="range" id="brightSlider" min="0" max="7" value="7">
      <span class="value" id="brightSliderVal">7</span>
    </div>

    <!-- Shuffle dwell time slider (ms) -->
    <div class="row">
      <label>Shuffle T (ms)</label>
      <input type="range" id="shuffleSlider" min="500" max="30000" step="500" value="5000">
      <span class="value" id="shuffleSliderVal">5000</span>
    </div>

    <!-- Boolean flags: shuffle, sleepTimer, powerLock -->
    <div>
      <h2>Flags</h2>
      <div class="bool-toggle">
        <input type="checkbox" id="shuffleFlag">
        <label for="shuffleFlag">Shuffle (shuffle_P)</label>
      </div>
      <div class="bool-toggle">
        <input type="checkbox" id="sleepTimerFlag" checked>
        <label for="sleepTimerFlag">Sleep Timer</label>
      </div>
      <div class="bool-toggle">
        <input type="checkbox" id="powerLockFlag">
        <label for="powerLockFlag">Power Lock</label>
      </div>
    </div>

    <!-- Simple debug text area to see latest telemetry lines / errors -->
    <div class="debug-box" id="debugBox">
      <!-- Filled from JS -->
    </div>
  </section>

  <!-- RIGHT SIDE: Graphs -->
  <section id="graphsSection">
    <h2>Sensor Graphs (last ~30s)</h2>
    <div class="graphs">
      <div>
        <div style="font-size:0.8rem; color:#aaa; margin-bottom:0.2rem;">Gyro (gx, gy, gz)</div>
        <canvas id="gyroCanvas" height="120"></canvas>
      </div>
      <div>
        <div style="font-size:0.8rem; color:#aaa; margin-bottom:0.2rem;">Accel (ax, ay, az)</div>
        <canvas id="accelCanvas" height="120"></canvas>
      </div>
      <div>
        <div style="font-size:0.8rem; color:#aaa; margin-bottom:0.2rem;">Mic Level</div>
        <canvas id="micCanvas" height="120"></canvas>
      </div>
    </div>
  </section>
</main>

<script>
  /************************************************************
   * BLE UART UUIDs (Nordic / Adafruit UART)
   *  - SERVICE: 6e400001-b5a3-f393-e0a9-e50e24dcca9e
   *  - RX CHAR (write):   6e400002-b5a3-f393-e0a9-e50e24dcca9e
   *  - TX CHAR (notify):  6e400003-b5a3-f393-e0a9-e50e24dcca9e
   ************************************************************/
  const UART_SERVICE_UUID = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
  const UART_RX_CHAR_UUID = '6e400002-b5a3-f393-e0a9-e50e24dcca9e';
  const UART_TX_CHAR_UUID = '6e400003-b5a3-f393-e0a9-e50e24dcca9e';

  // References to BLE objects
  let device = null;
  let server = null;
  let uartService = null;
  let rxChar = null; // write (GUI -> device)
  let txChar = null; // notify (device -> GUI)

  // UI elements
  const connectBtn = document.getElementById('connectBtn');
  const stateLabel = document.getElementById('stateLabel');
  const listLabel = document.getElementById('listLabel');
  const patternLabel = document.getElementById('patternLabel');
  const patternSlider = document.getElementById('patternSlider');
  const patternSliderVal = document.getElementById('patternSliderVal');
  const brightSlider = document.getElementById('brightSlider');
  const brightSliderVal = document.getElementById('brightSliderVal');
  const shuffleSlider = document.getElementById('shuffleSlider');
  const shuffleSliderVal = document.getElementById('shuffleSliderVal');
  const shuffleFlag = document.getElementById('shuffleFlag');
  const sleepTimerFlag = document.getElementById('sleepTimerFlag');
  const powerLockFlag = document.getElementById('powerLockFlag');
  const listCircles = document.getElementById('listCircles');
  const debugBox = document.getElementById('debugBox');

  /************************************************************
   * DATA STRUCTURES FOR GRAPHS
   * We keep ~600 points (30s @ 20Hz) for each series.
   ************************************************************/
  const MAX_POINTS = 600;
  let gyroData = { t: [], gx: [], gy: [], gz: [] };
  let accelData = { t: [], ax: [], ay: [], az: [] };
  let micData = { t: [], mic: [] };

  function trimArray(arr) {
    while (arr.length > MAX_POINTS) arr.shift();
  }

  // Push one new sensor sample (from TEL line) into buffers
  function pushSensorData(ms, ax, ay, az, gx, gy, gz, mic) {
    gyroData.t.push(ms);
    gyroData.gx.push(gx);
    gyroData.gy.push(gy);
    gyroData.gz.push(gz);

    accelData.t.push(ms);
    accelData.ax.push(ax);
    accelData.ay.push(ay);
    accelData.az.push(az);

    micData.t.push(ms);
    micData.mic.push(mic);

    trimArray(gyroData.t);
    trimArray(gyroData.gx);
    trimArray(gyroData.gy);
    trimArray(gyroData.gz);

    trimArray(accelData.t);
    trimArray(accelData.ax);
    trimArray(accelData.ay);
    trimArray(accelData.az);

    trimArray(micData.t);
    trimArray(micData.mic);
  }

  /************************************************************
   * CHART.JS SETUP
   ************************************************************/
  const gyroCtx = document.getElementById('gyroCanvas').getContext('2d');
  const accelCtx = document.getElementById('accelCanvas').getContext('2d');
  const micCtx = document.getElementById('micCanvas').getContext('2d');

  const gyroChart = new Chart(gyroCtx, {
    type: 'line',
    data: {
      labels: gyroData.t,
      datasets: [
        { label: 'gx', data: gyroData.gx, borderWidth: 1, pointRadius: 0 },
        { label: 'gy', data: gyroData.gy, borderWidth: 1, pointRadius: 0 },
        { label: 'gz', data: gyroData.gz, borderWidth: 1, pointRadius: 0 }
      ]
    },
    options: {
      animation: false,
      responsive: true,
      scales: {
        x: { display: false },
        y: {
          ticks: { color: '#aaa' },
          grid: { color: '#333' }
        }
      },
      plugins: {
        legend: { labels: { color: '#aaa' } }
      }
    }
  });

  const accelChart = new Chart(accelCtx, {
    type: 'line',
    data: {
      labels: accelData.t,
      datasets: [
        { label: 'ax', data: accelData.ax, borderWidth: 1, pointRadius: 0 },
        { label: 'ay', data: accelData.ay, borderWidth: 1, pointRadius: 0 },
        { label: 'az', data: accelData.az, borderWidth: 1, pointRadius: 0 }
      ]
    },
    options: {
      animation: false,
      responsive: true,
      scales: {
        x: { display: false },
        y: {
          ticks: { color: '#aaa' },
          grid: { color: '#333' }
        }
      },
      plugins: {
        legend: { labels: { color: '#aaa' } }
      }
    }
  });

  const micChart = new Chart(micCtx, {
    type: 'line',
    data: {
      labels: micData.t,
      datasets: [
        { label: 'mic', data: micData.mic, borderWidth: 1, pointRadius: 0 }
      ]
    },
    options: {
      animation: false,
      responsive: true,
      scales: {
        x: { display: false },
        y: {
          ticks: { color: '#aaa' },
          grid: { color: '#333' }
        }
      },
      plugins: {
        legend: { labels: { color: '#aaa' } }
      }
    }
  });

  // Periodically refresh charts with the latest data
  function updateCharts() {
    gyroChart.data.labels = gyroData.t;
    gyroChart.data.datasets[0].data = gyroData.gx;
    gyroChart.data.datasets[1].data = gyroData.gy;
    gyroChart.data.datasets[2].data = gyroData.gz;
    gyroChart.update('none');

    accelChart.data.labels = accelData.t;
    accelChart.data.datasets[0].data = accelData.ax;
    accelChart.data.datasets[1].data = accelData.ay;
    accelChart.data.datasets[2].data = accelData.az;
    accelChart.update('none');

    micChart.data.labels = micData.t;
    micChart.data.datasets[0].data = micData.mic;
    micChart.update('none');
  }

  setInterval(updateCharts, 200); // update charts 5x per second

  // Convert state ID (numeric) to text label
  function stateNameFromId(id) {
    switch (id) {
      case 0: return 'OFF';
      case 1: return 'PLAY';
      case 2: return 'SLEEP';
      case 3: return 'SHUFFLE';
      case 4: return 'PAIRING';
      case 5: return 'L_SELECT';
      case 6: return 'B_SELECT';
      case 7: return 'T_SELECT';
      default: return '?';
    }
  }

  /************************************************************
   * LIST CIRCLE UI
   ************************************************************/
  const listColors = [
    '#ffffff', // WHITE
    '#ff0000', // RED
    '#ff7f00', // ORANGE
    '#ffff00', // YELLOW
    '#00ff00', // GREEN
    '#0000ff', // BLUE
    '#4b0082', // INDIGO
    '#ee82ee', // VIOLET
    '#000000'  // BLACK (reserved)
  ];

  // Create a circle for each list index
  function buildListCircles() {
    listCircles.innerHTML = '';
    listColors.forEach((color, idx) => {
      const div = document.createElement('div');
      div.className = 'list-circle';
      div.style.background = color;
      div.title = `List ${idx}`;
      div.dataset.listIndex = idx.toString();
      div.addEventListener('click', () => {
        sendCommand(`SET:LIST:${idx}`);
        highlightActiveList(idx);
      });
      listCircles.appendChild(div);
    });
  }

  function highlightActiveList(idx) {
    Array.from(listCircles.children).forEach((child, i) => {
      child.classList.toggle('active', i === idx);
    });
  }

  buildListCircles();

  /************************************************************
   * CONNECT/DISCONNECT UI STATE
   ************************************************************/
  function setConnectedUI(connected) {
    if (connected) {
      connectBtn.textContent = 'Disconnect';
      connectBtn.classList.add('connected');
    } else {
      connectBtn.textContent = 'Connect';
      connectBtn.classList.remove('connected');
    }
  }

  /************************************************************
   * DEBUG LOGGING (visible in page), plus console.log
   ************************************************************/
  function logDebug(msg) {
    console.log(msg);
    const line = document.createElement('div');
    line.textContent = msg;
    debugBox.appendChild(line);
    // limit debug lines
    while (debugBox.children.length > 50) {
      debugBox.removeChild(debugBox.firstChild);
    }
    debugBox.scrollTop = debugBox.scrollHeight;
  }

  /************************************************************
   * BLE CONNECTION LOGIC
   ************************************************************/
  async function connect() {
    try {
      // Web Bluetooth device chooser
      device = await navigator.bluetooth.requestDevice({
        filters: [{ namePrefix: 'FiddleStIX_V1' }],
        optionalServices: [UART_SERVICE_UUID]
      });

      device.addEventListener('gattserverdisconnected', onDisconnected);

      server = await device.gatt.connect();
      uartService = await server.getPrimaryService(UART_SERVICE_UUID);
      rxChar = await uartService.getCharacteristic(UART_RX_CHAR_UUID);
      txChar = await uartService.getCharacteristic(UART_TX_CHAR_UUID);

      await txChar.startNotifications();
      txChar.addEventListener('characteristicvaluechanged', handleNotifications);

      setConnectedUI(true);
      logDebug('Connected to FiddleStIX_V1');

    } catch (err) {
      console.error('BLE connect error', err);
      alert('BLE connection failed: ' + err);
      setConnectedUI(false);
    }
  }

  async function disconnect() {
    try {
      if (device && device.gatt.connected) {
        await device.gatt.disconnect();
      }
    } catch (err) {
      console.error('BLE disconnect error', err);
    } finally {
      setConnectedUI(false);
      logDebug('Disconnected');
    }
  }

  function onDisconnected() {
    console.log('Device disconnected');
    setConnectedUI(false);
    logDebug('Device disconnected (GATT)');
  }

  /************************************************************
   * RECEIVING TELEMETRY OVER BLE
   * The device sends ASCII lines:
   *   TEL,ms,ax,ay,az,gx,gy,gz,mic,list,pattern,state\n
   *
   * Notifications may contain partial lines, so we accumulate
   * chunks into rxBuffer and split on '\n'.
   ************************************************************/
  let rxBuffer = '';

  function handleNotifications(event) {
    const value = event.target.value;
    const decoder = new TextDecoder('utf-8');
    const chunk = decoder.decode(value);

    // Append chunk to buffer
    rxBuffer += chunk;

    // Process all complete lines
    let newlineIndex;
    while ((newlineIndex = rxBuffer.indexOf('\n')) !== -1) {
      const line = rxBuffer.slice(0, newlineIndex).trim();
      rxBuffer = rxBuffer.slice(newlineIndex + 1);

      if (!line) continue;

      // For debugging: see lines in console + debug div
      logDebug('RX: ' + line);

      if (line.startsWith('TEL,')) {
        parseTelemetryLine(line);
      } else {
        // Some other message (not used yet)
      }
    }
  }

  // Parse one telemetry line and feed data into graphs + status labels
  function parseTelemetryLine(line) {
    // TEL,ms,ax,ay,az,gx,gy,gz,mic,list,pattern,state
    const parts = line.split(',');
    if (parts.length < 12) return;

    const ms = parseInt(parts[1]);
    const ax = parseFloat(parts[2]);
    const ay = parseFloat(parts[3]);
    const az = parseFloat(parts[4]);
    const gx = parseFloat(parts[5]);
    const gy = parseFloat(parts[6]);
    const gz = parseFloat(parts[7]);
    const mic = parseFloat(parts[8]);
    const list = parseInt(parts[9]);
    const pattern = parseInt(parts[10]);
    const state = parseInt(parts[11]);

    // Push to graphs
    pushSensorData(ms, ax, ay, az, gx, gy, gz, mic);

    // Update state labels
    stateLabel.textContent = stateNameFromId(state);
    listLabel.textContent = list.toString();
    patternLabel.textContent = pattern.toString();

    // Keep UI slider + list highlight roughly in sync
    patternSlider.value = pattern;
    patternSliderVal.textContent = pattern.toString();
    highlightActiveList(list);
  }

  /************************************************************
   * SENDING COMMANDS OVER BLE UART
   * Commands are one-line ASCII strings ending in '\n'
   ************************************************************/
  async function sendCommand(str) {
    if (!rxChar) {
      alert('Not connected to device');
      return;
    }
    const data = new TextEncoder().encode(str + '\n');
    try {
      await rxChar.writeValue(data);
      logDebug('TX: ' + str);
    } catch (err) {
      console.error('sendCommand error', err);
      logDebug('sendCommand error: ' + err);
    }
  }

  /************************************************************
   * UI EVENT HOOKS
   ************************************************************/
  // Connect/disconnect toggle button
  connectBtn.addEventListener('click', () => {
    if (device && device.gatt && device.gatt.connected) {
      disconnect();
    } else {
      connect();
    }
  });

  // Control buttons -> send CMD:... lines
  document.querySelectorAll('.controls-grid button').forEach(btn => {
    btn.addEventListener('click', () => {
      const cmd = btn.dataset.cmd;
      if (cmd) sendCommand(cmd);
    });
  });

  // Pattern slider -> SET:PATTERN:...
  patternSlider.addEventListener('input', () => {
    patternSliderVal.textContent = patternSlider.value;
  });
  patternSlider.addEventListener('change', () => {
    sendCommand(`SET:PATTERN:${patternSlider.value}`);
  });

  // Brightness slider -> SET:BRIGHT:...
  brightSlider.addEventListener('input', () => {
    brightSliderVal.textContent = brightSlider.value;
  });
  brightSlider.addEventListener('change', () => {
    sendCommand(`SET:BRIGHT:${brightSlider.value}`);
  });

  // Shuffle dwell time slider -> SET:SHUFFLE_T:...
  shuffleSlider.addEventListener('input', () => {
    shuffleSliderVal.textContent = shuffleSlider.value;
  });
  shuffleSlider.addEventListener('change', () => {
    sendCommand(`SET:SHUFFLE_T:${shuffleSlider.value}`);
  });

  // Boolean flags -> SET:BOOL:...:...
  shuffleFlag.addEventListener('change', () => {
    sendCommand(`SET:BOOL:shuffle:${shuffleFlag.checked ? 1 : 0}`);
  });
  sleepTimerFlag.addEventListener('change', () => {
    sendCommand(`SET:BOOL:sleepTimer:${sleepTimerFlag.checked ? 1 : 0}`);
  });
  powerLockFlag.addEventListener('change', () => {
    sendCommand(`SET:BOOL:powerLock:${powerLockFlag.checked ? 1 : 0}`);
  });
</script>
</body>
</html>
