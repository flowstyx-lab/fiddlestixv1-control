<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>FiddleStIX Pattern Generator</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 20px; }
    .row { display:flex; gap:14px; flex-wrap:wrap; margin-bottom:12px; }
    label { font-size: 13px; display:block; opacity:0.9; margin-bottom:4px; }
    input, select { padding: 8px; font-size: 14px; width: 220px; }
    textarea { width: 100%; height: 320px; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size: 12px; padding: 10px; }
    .btn { padding: 10px 14px; font-size: 14px; cursor: pointer; }
    .hint { font-size: 12px; opacity: 0.75; }
  </style>
</head>
<body>
  <h2>FiddleStIX Pattern Generator</h2>
  <div class="hint">
    Output uses firmware ranges: sat/pb are 0..255. Color is 0..252 (+ whites 253..255).
  </div>

  <div class="row">
    <div>
      <label>p_Symmetry</label>
      <select id="sym">
        <option value="0">0 (wrap)</option>
        <option value="1">1 (bounce)</option>
      </select>
    </div>

    <div>
      <label>p_Type</label>
      <select id="type">
        <option value="0">0 (all 3 same)</option>
        <option value="1">1 (only LED0)</option>
        <option value="2">2 (split colors)</option>
      </select>
    </div>

    <div>
      <label>p_Split (0..7)</label>
      <select id="split">
        <option value="0">0 (+/-84)</option>
        <option value="1">1 (+/-74)</option>
        <option value="2">2 (+/-64)</option>
        <option value="3">3 (+/-54)</option>
        <option value="4">4 (+/-44)</option>
        <option value="5">5 (+/-34)</option>
        <option value="6">6 (+/-24)</option>
        <option value="7">7 (+/-14)</option>
      </select>
    </div>

    <div>
      <label>p_Duration (ms)</label>
      <input id="dur" type="number" value="8000" min="200" step="50"/>
    </div>
  </div>

  <div class="row">
    <div>
      <label>Base Color (0..252, 253..255 whites)</label>
      <input id="color" type="number" value="0" min="0" max="255" step="1"/>
    </div>

    <div>
      <label>Saturation % (0..100)</label>
      <input id="satpct" type="number" value="100" min="0" max="100" step="1"/>
    </div>

    <div>
      <label>Brightness % (min 40)</label>
      <input id="pbpct" type="number" value="80" min="40" max="100" step="1"/>
    </div>

    <div>
      <label>Pattern Builder</label>
      <select id="builder">
        <option value="solid">Solid</option>
        <option value="pulse_soft">Pulse (soft)</option>
        <option value="pulse_hard">Pulse (hard on/off)</option>
        <option value="strobe">Strobe (Hz)</option>
        <option value="rainbow_slide">Rainbow Slide</option>
        <option value="strobefade">Strobefade (fade + strobe mask)</option>
        <option value="accel_strobe">Accelerando Strobe (Hz1→Hz2)</option>
        <option value="accel_strobefade">Accel Strobefade (fade + Hz1→Hz2)</option>
      </select>
    </div>
  </div>

  <div class="row" id="paramsRow"></div>

  <div class="row">
    <button class="btn" id="gen">Generate C++</button>
    <button class="btn" id="copy">Copy Output</button>
  </div>

  <textarea id="out" spellcheck="false"></textarea>

<script>
const $ = (id)=>document.getElementById(id);

function pbFromPct(p){ return Math.round(Math.max(0,Math.min(100,p))*255/100); }
function satFromPct(p){ return Math.round(Math.max(0,Math.min(100,p))*255/100); }

function wrapHue(v){
  // wrap only for wheel range 0..252
  while(v<0) v+=253;
  while(v>252) v-=253;
  return v;
}

function step(slide,on,color,sat,pb,dur){
  return {slide,on,color,sat,pb,dur};
}

function renderSteps(steps){
  return steps.map(s=>`  {${s.slide},${s.on},${s.color},${s.sat},${s.pb},${s.dur}}`).join(",\n");
}

// Expand a strobe mask into explicit on/off steps over totalMs.
// duty: 0..1
function buildStrobeSteps(baseColor, sat, pb, totalMs, hz, duty=0.5){
  hz = Math.max(0.2, hz);
  const period = 1000/hz;
  const onMs = Math.max(10, Math.round(period*duty));
  const offMs = Math.max(10, Math.round(period - onMs));
  let t=0, steps=[];
  while(t < totalMs-5){
    const a = Math.min(onMs, totalMs - t); t += a;
    steps.push(step(0,1,baseColor,sat,pb,a));
    if(t >= totalMs-5) break;
    const b = Math.min(offMs, totalMs - t); t += b;
    steps.push(step(0,0,baseColor,sat,0,b));
  }
  return steps;
}

// Fade color from c0 to c1 over ms, with slide steps
function buildColorSlide(c0,c1,sat,pb,ms){
  return [
    step(0,1,c0,sat,pb,20),
    step(1,1,c1,sat,pb,ms)
  ];
}

// “Strobefade”: make a smooth color slide, then overlay a strobe by converting into explicit slices.
// Here we approximate by chopping into small time slices and alternating on/off.
function buildStrobeFade(c0,c1,sat,pb,totalMs,hz){
  hz = Math.max(0.2, hz);
  const period = 1000/hz;
  const slice = Math.max(20, Math.round(period/2));
  const slices = Math.max(2, Math.floor(totalMs / slice));
  let steps=[];
  for(let i=0;i<slices;i++){
    const t0 = i/(slices-1);
    // interpolate hue on wheel (simple forward interpolation; ok for experimentation)
    const c = wrapHue(Math.round(c0 + (c1-c0)*t0));
    const on = (i%2===0);
    steps.push(step(0,on?1:0,c,sat,on?pb:0,slice));
  }
  // cleanup remainder
  const used = slices*slice;
  const rem = totalMs-used;
  if(rem>0){
    const c = c1;
    steps.push(step(0,1,c,sat,pb,rem));
  }
  return steps;
}

// Accelerando strobe: explicit on/off with hz increasing linearly
function buildAccelStrobe(baseColor,sat,pb,totalMs,hz1,hz2){
  hz1=Math.max(0.2,hz1); hz2=Math.max(0.2,hz2);
  let t=0, steps=[];
  while(t<totalMs-5){
    const x = t/totalMs;
    const hz = hz1 + (hz2-hz1)*x;
    const period = 1000/hz;
    const onMs = Math.max(10, Math.round(period*0.5));
    const offMs = Math.max(10, Math.round(period - onMs));
    const a = Math.min(onMs, totalMs-t); t+=a;
    steps.push(step(0,1,baseColor,sat,pb,a));
    if(t>=totalMs-5) break;
    const b = Math.min(offMs, totalMs-t); t+=b;
    steps.push(step(0,0,baseColor,sat,0,b));
  }
  return steps;
}

function buildUIParams(){
  const b = $("builder").value;
  const row = $("paramsRow");
  row.innerHTML = "";

  function addNum(id,label,val,min,max,stepv){
    const d=document.createElement("div");
    d.innerHTML = `<label>${label}</label><input id="${id}" type="number" value="${val}" min="${min}" max="${max}" step="${stepv}"/>`;
    row.appendChild(d);
  }

  if(b==="strobe"){
    addNum("hz","Strobe Hz",10,0.2,60,0.1);
  } else if(b==="rainbow_slide"){
    addNum("laps","Laps (wheel turns)",1,0.1,10,0.1);
  } else if(b==="strobefade"){
    addNum("hz","Strobe Hz",12,0.2,60,0.1);
    addNum("to","Target Color (0..252)",168,0,252,1);
  } else if(b==="accel_strobe"){
    addNum("hz1","Start Hz",4,0.2,60,0.1);
    addNum("hz2","End Hz",18,0.2,60,0.1);
  } else if(b==="accel_strobefade"){
    addNum("hz1","Start Hz",4,0.2,60,0.1);
    addNum("hz2","End Hz",18,0.2,60,0.1);
    addNum("to","Target Color (0..252)",224,0,252,1);
  } else if(b==="pulse_soft"){
    addNum("depth","Pulse Depth %",35,5,80,1);
  } else if(b==="pulse_hard"){
    addNum("onms","On ms",120,10,2000,10);
    addNum("offms","Off ms",80,10,2000,10);
  }
}

$("builder").addEventListener("change", buildUIParams);
buildUIParams();

$("gen").addEventListener("click", ()=>{
  const symmetry = parseInt($("sym").value,10);
  const type     = parseInt($("type").value,10);
  const split    = parseInt($("split").value,10);
  const durMs    = Math.max(50, parseInt($("dur").value,10)||8000);

  let color = parseInt($("color").value,10); color = Math.max(0,Math.min(255,color));
  const sat = satFromPct(parseFloat($("satpct").value||100));
  const pb  = pbFromPct(parseFloat($("pbpct").value||80));

  const builder = $("builder").value;

  let steps=[];
  if(builder==="solid"){
    steps=[step(0,1,color,sat,pb,durMs)];
  }
  else if(builder==="pulse_soft"){
    const depth = parseFloat($("depth")?.value||35);
    const loPct = Math.max(40, Math.min(100, (pb/255*100) - depth));
    const pbLo  = pbFromPct(loPct);
    const seg = Math.max(80, Math.round(durMs/3));
    steps=[
      step(0,1,color,sat,pbLo,20),
      step(1,1,color,sat,pb,seg),
      step(1,1,color,sat,pbLo,seg)
    ];
  }
  else if(builder==="pulse_hard"){
    const onms = Math.max(10, parseInt($("onms")?.value||120,10));
    const offms= Math.max(10, parseInt($("offms")?.value||80,10));
    let t=0;
    while(t<durMs-5){
      const a=Math.min(onms,durMs-t); t+=a;
      steps.push(step(0,1,color,sat,pb,a));
      if(t>=durMs-5) break;
      const b=Math.min(offms,durMs-t); t+=b;
      steps.push(step(0,0,color,sat,0,b));
    }
  }
  else if(builder==="strobe"){
    const hz = parseFloat($("hz")?.value||10);
    steps = buildStrobeSteps(color,sat,pb,durMs,hz,0.5);
  }
  else if(builder==="rainbow_slide"){
    const laps = parseFloat($("laps")?.value||1);
    const target = (color<=252) ? wrapHue(Math.round(color + 253*laps)) : color;
    // slide in 4 chunks for nicer shape
    if(color<=252){
      const c0=color;
      const c1=wrapHue(Math.round(c0 + 63*laps));
      const c2=wrapHue(Math.round(c0 + 126*laps));
      const c3=wrapHue(Math.round(c0 + 189*laps));
      const ms = Math.max(200, Math.round(durMs/4));
      steps=[
        step(0,1,c0,sat,pb,20),
        step(1,1,c1,sat,pb,ms),
        step(1,1,c2,sat,pb,ms),
        step(1,1,c3,sat,pb,ms),
        step(1,1,wrapHue(Math.round(c0+252*laps)),sat,pb,ms)
      ];
    } else {
      steps=[step(0,1,color,sat,pb,durMs)];
    }
  }
  else if(builder==="strobefade"){
    const hz = parseFloat($("hz")?.value||12);
    const to = wrapHue(parseInt($("to")?.value||168,10));
    steps = buildStrobeFade(color<=252?color:0,to,sat,pb,durMs,hz);
  }
  else if(builder==="accel_strobe"){
    const hz1 = parseFloat($("hz1")?.value||4);
    const hz2 = parseFloat($("hz2")?.value||18);
    steps = buildAccelStrobe(color,sat,pb,durMs,hz1,hz2);
  }
  else if(builder==="accel_strobefade"){
    const hz1 = parseFloat($("hz1")?.value||4);
    const hz2 = parseFloat($("hz2")?.value||18);
    const to = wrapHue(parseInt($("to")?.value||224,10));
    // approximate: color slides overall, strobe accel slices
    // (simple: generate accel strobe, but nudge hue forward over time)
    let t=0; steps=[];
    while(t<durMs-5){
      const x=t/durMs;
      const hz=hz1+(hz2-hz1)*x;
      const period=1000/hz;
      const onMs=Math.max(10,Math.round(period*0.5));
      const offMs=Math.max(10,Math.round(period-onMs));
      const hue = wrapHue(Math.round((color<=252?color:0) + (to-(color<=252?color:0))*x));
      const a=Math.min(onMs,durMs-t); t+=a;
      steps.push(step(0,1,hue,sat,pb,a));
      if(t>=durMs-5) break;
      const b=Math.min(offMs,durMs-t); t+=b;
      steps.push(step(0,0,hue,sat,0,b));
    }
  }

  // cap steps for firmware friendliness if you paste directly
  if(steps.length > 16) steps = steps.slice(0,16);

  const arrName = `P_CUSTOM_${Date.now().toString(16).toUpperCase()}`;
  const out =
`// --- Generated by Pattern Generator ---
static const Step ${arrName}[] = {
${renderSteps(steps)}
};

// symmetry,type,split,stepCount,steps
static const LedPattern CUSTOM_PATTERN = { ${symmetry}, ${type}, ${split}, ${steps.length}, ${arrName} };
`;
  $("out").value = out;
});

$("copy").addEventListener("click", async ()=>{
  $("out").select();
  document.execCommand("copy");
});
</script>
</body>
</html>
